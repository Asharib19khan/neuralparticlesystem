<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Magical Hand-Tracked Particles</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Courier New', sans-serif; }
        canvas { display: block; }
        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #00ffcc;
            pointer-events: none;
            z-index: 10;
        }
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 24px;
            text-align: center;
        }
        .instruction { font-size: 14px; opacity: 0.8; margin-top: 5px; }
    </style>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <div id="ui">
        <h2>‚ú® AI Particle Magic</h2>
        <div class="instruction">üëã <b>Move Hand:</b> Guide Particles</div>
        <div class="instruction">üëå <b>Pinch & Hold:</b> Implode / Charge Energy</div>
        <div class="instruction">üñê <b>Release Pinch:</b> Explode & Change Shape</div>
        <div id="status" style="margin-top:10px; color: yellow;">Initializing AI...</div>
    </div>

    <div id="loading">Loading Computer Vision Models...</div>

    <video id="input_video" style="display:none"></video>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        // --- CONFIGURATION ---
        const PARTICLE_COUNT = 12000;
        const PARTICLE_SIZE = 0.08;
        const CAM_Z = 30;

        // --- STATE ---
        const state = {
            handDetected: false,
            handPos: new THREE.Vector3(0, 0, 0), // Normalized -1 to 1
            pinchStrength: 0, // 0 to 1
            currentShapeIndex: 0,
            time: 0
        };

        // --- SCENE SETUP ---
        const scene = new THREE.Scene();
        // Add subtle fog for depth
        scene.fog = new THREE.FogExp2(0x000000, 0.02);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.z = CAM_Z;

        const renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance" });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.body.appendChild(renderer.domElement);

        // --- POST PROCESSING (BLOOM) ---
        const renderScene = new RenderPass(scene, camera);
        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        bloomPass.threshold = 0;
        bloomPass.strength = 1.2; // Glow intensity
        bloomPass.radius = 0.5;

        const composer = new EffectComposer(renderer);
        composer.addPass(renderScene);
        composer.addPass(bloomPass);

        // --- SHAPE GENERATORS ---
        // Helper functions to calculate target positions for different shapes
        const shapes = [];

        function generateShapes() {
            // 1. Sphere (Chaos)
            const sphere = new Float32Array(PARTICLE_COUNT * 3);
            for (let i = 0; i < PARTICLE_COUNT * 3; i += 3) {
                const r = 10 * Math.cbrt(Math.random());
                const theta = Math.random() * 2 * Math.PI;
                const phi = Math.acos(2 * Math.random() - 1);
                sphere[i] = r * Math.sin(phi) * Math.cos(theta);
                sphere[i+1] = r * Math.sin(phi) * Math.sin(theta);
                sphere[i+2] = r * Math.cos(phi);
            }
            shapes.push({ data: sphere, color: new THREE.Color(0x00ffff) }); // Cyan

            // 2. Heart
            const heart = new Float32Array(PARTICLE_COUNT * 3);
            for (let i = 0; i < PARTICLE_COUNT * 3; i += 3) {
                let t = Math.random() * Math.PI * 2;
                let u = Math.random() * Math.PI * 2; // For volume
                // Heart formula
                let x = 16 * Math.pow(Math.sin(t), 3);
                let y = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
                let scale = 0.5;
                // Add thickness
                let z = (Math.random() - 0.5) * 5; 
                heart[i] = x * scale;
                heart[i+1] = y * scale;
                heart[i+2] = z;
            }
            shapes.push({ data: heart, color: new THREE.Color(0xff0055) }); // Pink/Red

            // 3. Saturn (Ring + Sphere)
            const saturn = new Float32Array(PARTICLE_COUNT * 3);
            for (let i = 0; i < PARTICLE_COUNT * 3; i += 3) {
                const isRing = Math.random() > 0.4; // 60% ring, 40% planet
                if (isRing) {
                    const angle = Math.random() * Math.PI * 2;
                    const r = 12 + Math.random() * 6;
                    saturn[i] = Math.cos(angle) * r;
                    saturn[i+1] = (Math.random() - 0.5) * 0.5; // Flat y
                    saturn[i+2] = Math.sin(angle) * r;
                } else {
                    const r = 6;
                    const theta = Math.random() * 2 * Math.PI;
                    const phi = Math.acos(2 * Math.random() - 1);
                    saturn[i] = r * Math.sin(phi) * Math.cos(theta);
                    saturn[i+1] = r * Math.sin(phi) * Math.sin(theta);
                    saturn[i+2] = r * Math.cos(phi);
                }
            }
            shapes.push({ data: saturn, color: new THREE.Color(0xffaa00) }); // Orange/Gold

            // 4. DNA Helix / Tornado
            const helix = new Float32Array(PARTICLE_COUNT * 3);
            for (let i = 0; i < PARTICLE_COUNT * 3; i += 3) {
                let t = (i / (PARTICLE_COUNT*3)) * 20; // Height factor
                let angle = t * 2;
                let r = 5;
                helix[i] = Math.cos(angle) * r;
                helix[i+1] = (t - 10) * 1.5; // Center vertically
                helix[i+2] = Math.sin(angle) * r;
                // Add some noise
                helix[i] += (Math.random()-0.5);
            }
            shapes.push({ data: helix, color: new THREE.Color(0x00ff00) }); // Green
        }

        generateShapes();

        // --- PARTICLE SYSTEM CREATION ---
        const geometry = new THREE.BufferGeometry();
        
        // Initial Positions
        const positions = new Float32Array(PARTICLE_COUNT * 3);
        // Target Positions (for morphing)
        const targets = new Float32Array(PARTICLE_COUNT * 3);
        // Randomness (for twinkle/jitter)
        const randoms = new Float32Array(PARTICLE_COUNT);
        
        for (let i = 0; i < PARTICLE_COUNT * 3; i++) {
            positions[i] = (Math.random() - 0.5) * 50;
            targets[i] = shapes[0].data[i];
            if (i % 3 === 0) randoms[i/3] = Math.random();
        }

        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.setAttribute('target', new THREE.BufferAttribute(targets, 3));
        geometry.setAttribute('aRandom', new THREE.BufferAttribute(randoms, 1));

        // --- CUSTOM SHADER MATERIAL ---
        // This is where the magic happens on the GPU
        const material = new THREE.ShaderMaterial({
            uniforms: {
                uTime: { value: 0 },
                uColor: { value: shapes[0].color },
                uMouse: { value: new THREE.Vector3(0, 0, 0) }, // Hand Position
                uPinch: { value: 0 }, // 0 = normal, 1 = fully pinched
                uMix: { value: 0 } // Morph progress
            },
            vertexShader: `
                uniform float uTime;
                uniform float uPinch;
                uniform vec3 uMouse;
                
                attribute vec3 target;
                attribute float aRandom;
                
                varying float vAlpha;
                
                // Simplex Noise Function (Simplified)
                vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
                vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
                vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }
                vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }
                float snoise(vec3 v) {
                    const vec2 C = vec2(1.0/6.0, 1.0/3.0);
                    const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);
                    vec3 i  = floor(v + dot(v, C.yyy) );
                    vec3 x0 = v - i + dot(i, C.xxx) ;
                    vec3 g = step(x0.yzx, x0.xyz);
                    vec3 l = 1.0 - g;
                    vec3 i1 = min( g.xyz, l.zxy );
                    vec3 i2 = max( g.xyz, l.zxy );
                    vec3 x1 = x0 - i1 + C.xxx;
                    vec3 x2 = x0 - i2 + C.yyy;
                    vec3 x3 = x0 - 1.0 + 2.0 * C.xxx;
                    i = mod289(i); 
                    vec4 p = permute( permute( permute( 
                        i.z + vec4(0.0, i1.z, i2.z, 1.0 ))
                        + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) 
                        + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));
                    float n_ = 0.142857142857;
                    vec3  ns = n_ * D.wyz - D.xzx;
                    vec4 j = p - 49.0 * floor(p * ns.z * ns.z);
                    vec4 x_ = floor(j * ns.z);
                    vec4 y_ = floor(j - 7.0 * x_ );
                    vec4 x = x_ *ns.x + ns.yyyy;
                    vec4 y = y_ *ns.x + ns.yyyy;
                    vec4 h = 1.0 - abs(x) - abs(y);
                    vec4 b0 = vec4( x.xy, y.xy );
                    vec4 b1 = vec4( x.zw, y.zw );
                    vec4 s0 = floor(b0)*2.0 + 1.0;
                    vec4 s1 = floor(b1)*2.0 + 1.0;
                    vec4 sh = -step(h, vec4(0.0));
                    vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;
                    vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;
                    vec3 p0 = vec3(a0.xy,h.x);
                    vec3 p1 = vec3(a0.zw,h.y);
                    vec3 p2 = vec3(a1.xy,h.z);
                    vec3 p3 = vec3(a1.zw,h.w);
                    vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));
                    p0 *= norm.x; p1 *= norm.y; p2 *= norm.z; p3 *= norm.w;
                    vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
                    m = m * m;
                    return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3) ) );
                }

                void main() {
                    // Mix current position and target position (handled largely in JS via attribute update, 
                    // but we add noise and interaction here)
                    vec3 pos = position; // The 'position' attribute is actually being morphed in JS loop
                    
                    // 1. Noise Movement (Idle animation)
                    float noise = snoise(pos * 0.1 + uTime * 0.5);
                    pos += normal * noise * 0.5;

                    // 2. Hand Interaction
                    // Calculate distance to hand (uMouse is in world space)
                    float dist = distance(pos, uMouse);
                    
                    // Attraction/Repulsion logic
                    // If pinching (uPinch -> 1), particles suck into hand
                    // If not pinching (uPinch -> 0), particles gently float around
                    
                    vec3 dir = normalize(uMouse - pos);
                    
                    // IMPLOSION EFFECT: heavily pull towards hand when pinching
                    float pullStrength = uPinch * 15.0 * (1.0 / (dist + 0.1));
                    pos += dir * pullStrength;

                    // REPULSION/SWIRL when close but not pinching
                    if (dist < 8.0 && uPinch < 0.1) {
                        pos -= dir * (2.0 / (dist + 0.1)); // Push away slightly
                    }

                    vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
                    gl_Position = projectionMatrix * mvPosition;
                    
                    // Size attenuation
                    gl_PointSize = (120.0 / -mvPosition.z);
                    
                    // Fade out if very close to camera
                    vAlpha = smoothstep(0.0, 5.0, -mvPosition.z);
                }
            `,
            fragmentShader: `
                uniform vec3 uColor;
                varying float vAlpha;

                void main() {
                    // Circular particle
                    vec2 coord = gl_PointCoord - vec2(0.5);
                    float r = length(coord);
                    if (r > 0.5) discard;

                    // Soft edge glow
                    float glow = 1.0 - (r * 2.0);
                    glow = pow(glow, 1.5);

                    gl_FragColor = vec4(uColor, vAlpha * glow);
                }
            `,
            transparent: true,
            depthWrite: false,
            blending: THREE.AdditiveBlending
        });

        const particles = new THREE.Points(geometry, material);
        scene.add(particles);

        // --- ANIMATION & MORPH LOGIC ---
        // We handle the morphing "mix" in Javascript by updating the Position attribute directly
        // This is a hybrid CPU/GPU approach for maximum flexibility with shape templates.
        
        let morphSpeed = 0.03;
        
        function updateParticles() {
            const positions = particles.geometry.attributes.position.array;
            const targets = shapes[state.currentShapeIndex].data;
            const currentShapeColor = shapes[state.currentShapeIndex].color;
            
            // Lerp Color
            material.uniforms.uColor.value.lerp(currentShapeColor, 0.05);

            // Morph Positions
            // If we are pinching, we don't morph to shape, we implode (handled in shader)
            // But we need the base positions to move towards target
            
            const count = PARTICLE_COUNT * 3;
            for (let i = 0; i < count; i++) {
                // Simple Linear Interpolation towards target shape
                positions[i] += (targets[i] - positions[i]) * morphSpeed;
            }
            particles.geometry.attributes.position.needsUpdate = true;
        }


        // --- MEDIAPIPE HANDS SETUP ---
        const videoElement = document.getElementById('input_video');
        const statusElement = document.getElementById('status');
        const loadingElement = document.getElementById('loading');

        const hands = new Hands({locateFile: (file) => {
            return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
        }});

        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 1,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });

        hands.onResults(onResults);

        // Calculate pinch distance
        function getDistance(p1, p2) {
            return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
        }

        let isPinching = false;
        let prevPinch = false;

        function onResults(results) {
            loadingElement.style.display = 'none';
            
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                state.handDetected = true;
                statusElement.innerText = "Tracking Active";
                statusElement.style.color = "#00ffcc";

                const landmarks = results.multiHandLandmarks[0];
                
                // 1. Get Hand Position (Index finger tip) and map to 3D world
                // MediaPipe x is 0(left) to 1(right). Three.js is -x(left) to +x(right).
                // MediaPipe y is 0(top) to 1(bottom). Three.js is +y(top) to -y(bottom).
                
                const x = (1.0 - landmarks[8].x) * 2 - 1; // Invert X for mirror effect
                const y = -(landmarks[8].y * 2 - 1);
                
                // Map to approximate World Coordinates at Z=0
                // Assuming Camera Z = 30, FOV = 75
                const vFOV = THREE.MathUtils.degToRad(75);
                const height = 2 * Math.tan(vFOV / 2) * CAM_Z;
                const width = height * (window.innerWidth / window.innerHeight);

                state.handPos.set(x * (width/2), y * (height/2), 0);

                // 2. Detect Pinch (Index Tip [8] vs Thumb Tip [4])
                const pinchDist = getDistance(landmarks[8], landmarks[4]);
                
                // Heuristic for pinch (0.05 is usually a good threshold)
                state.pinchStrength = Math.max(0, Math.min(1, (0.08 - pinchDist) * 20)); // Map distance to 0-1 strength
                
                isPinching = state.pinchStrength > 0.8;

                // 3. Logic: If Pinch Released -> Switch Shape
                if (prevPinch && !isPinching) {
                    // Explosion trigger
                    triggerExplosion();
                }
                prevPinch = isPinching;

            } else {
                state.handDetected = false;
                statusElement.innerText = "No Hand Detected";
                statusElement.style.color = "orange";
                state.pinchStrength = 0; // Reset pinch
                
                // Fallback: Use mouse if no hand
                // (Already mapped via event listener below)
            }
        }

        function triggerExplosion() {
            // Switch to next shape
            state.currentShapeIndex = (state.currentShapeIndex + 1) % shapes.length;
            
            // Visual "Explosion" via shader bloom intensity or rapid expansion
            bloomPass.strength = 3.0; // Flash
            setTimeout(() => { bloomPass.strength = 1.2; }, 300);
            
            // Randomly scatter particles temporarily for explosion effect
            const positions = particles.geometry.attributes.position.array;
            for(let i=0; i<PARTICLE_COUNT*3; i++) {
                positions[i] += (Math.random()-0.5) * 10;
            }
        }

        // Camera Initialization
        const cameraUtils = new Camera(videoElement, {
            onFrame: async () => {
                await hands.send({image: videoElement});
            },
            width: 640,
            height: 480
        });
        cameraUtils.start();

        // Mouse Fallback
        document.addEventListener('mousemove', (e) => {
            if (!state.handDetected) {
                const x = (e.clientX / window.innerWidth) * 2 - 1;
                const y = -(e.clientY / window.innerHeight) * 2 + 1;
                
                const vFOV = THREE.MathUtils.degToRad(75);
                const height = 2 * Math.tan(vFOV / 2) * CAM_Z;
                const width = height * (window.innerWidth / window.innerHeight);
                
                state.handPos.set(x * (width/2), y * (height/2), 0);
            }
        });
        document.addEventListener('mousedown', () => { if(!state.handDetected) { state.pinchStrength = 1; prevPinch = true; }});
        document.addEventListener('mouseup', () => { 
            if(!state.handDetected) { 
                state.pinchStrength = 0; 
                triggerExplosion();
                prevPinch = false;
            }
        });


        // --- RENDER LOOP ---
        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);

            const elapsedTime = clock.getElapsedTime();
            state.time = elapsedTime;

            // Update Uniforms
            material.uniforms.uTime.value = elapsedTime;
            
            // Smoothly interpolate the "Mouse" uniform to the hand position
            const currentMouse = material.uniforms.uMouse.value;
            currentMouse.lerp(state.handPos, 0.1);
            
            // Smoothly interpolate pinch strength
            material.uniforms.uPinch.value += (state.pinchStrength - material.uniforms.uPinch.value) * 0.1;

            // Update CPU Geometry (Morphing)
            updateParticles();

            // Rotate entire system slowly
            particles.rotation.y = elapsedTime * 0.05;
            particles.rotation.z = elapsedTime * 0.02;

            // Render with Bloom
            composer.render();
        }

        animate();

        // Handle Resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });

    </script>
</body>
</html>
