<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neural Particle System</title>
    
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Rajdhani:wght@300;500;700&display=swap" rel="stylesheet">

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #050505;
            font-family: 'Rajdhani', sans-serif;
            user-select: none;
        }

        #canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 1;
        }

        /* Hide the webcam video element, we only want the data */
        .input_video {
            display: none;
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 40px;
            box-sizing: border-box;
        }

        h1 {
            color: #fff;
            font-weight: 700;
            font-size: 2rem;
            text-transform: uppercase;
            letter-spacing: 2px;
            margin: 0;
            text-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
        }

        .status {
            color: #00ffff;
            font-size: 1.2rem;
            margin-top: 10px;
        }

        .controls-info {
            color: rgba(255, 255, 255, 0.8);
            font-size: 1rem;
            text-align: right;
            line-height: 1.6;
            background: rgba(0, 0, 0, 0.5);
            padding: 20px;
            border-radius: 8px;
            border: 1px solid rgba(0, 255, 255, 0.2);
            backdrop-filter: blur(5px);
            align-self: flex-end;
            max-width: 300px;
        }

        .controls-info b {
            color: #00ffff;
        }

        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #00ffff;
            font-size: 2rem;
            font-weight: 300;
            z-index: 10;
            letter-spacing: 5px;
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0% { opacity: 0.5; text-shadow: 0 0 5px #00ffff; }
            50% { opacity: 1; text-shadow: 0 0 20px #00ffff; }
            100% { opacity: 0.5; text-shadow: 0 0 5px #00ffff; }
        }
    </style>
</head>
<body>

    <div id="loading">INITIALIZING NEURAL LINK...</div>

    <div id="ui-layer">
        <div>
            <h1>Quantum Particle Field</h1>
            <div class="status" id="status-text">Waiting for camera...</div>
        </div>
        
        <div class="controls-info">
            <p><b>OPEN PALM</b> :: Attract Particles</p>
            <p><b>CLOSED FIST</b> :: Supernova Explosion</p>
            <p><b>PINCH FINGERS</b> :: Shape Shift</p>
            <p><b>TWO HANDS</b> :: Chaos Mode</p>
        </div>
    </div>

    <video class="input_video"></video>
    
    <div id="canvas-container"></div>

    <script>
        // --- CONFIGURATION ---
        const PARTICLE_COUNT = 18000;
        const CAM_Z = 400;
        const PARTICLE_SIZE = 1.8;
        
        // --- STATE MANAGEMENT ---
        let scene, camera, renderer;
        let particles, geometry, material;
        let positions, velocities, targetPositions, colors;
        let clock = new THREE.Clock();
        let time = 0;
        
        // Hand State
        let handPosition = new THREE.Vector3(0, 0, 0);
        let isHandPresent = false;
        let isFist = false;
        let isPinching = false;
        let pinchCooldown = false;
        let currentShapeIndex = 0;
        
        // --- SHAPES GENERATOR ---
        const Shapes = {
            CUBE: (i) => {
                const s = 200;
                return {
                    x: (Math.random() - 0.5) * s,
                    y: (Math.random() - 0.5) * s,
                    z: (Math.random() - 0.5) * s
                };
            },
            SPHERE: (i) => {
                const r = 100;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos((Math.random() * 2) - 1);
                return {
                    x: r * Math.sin(phi) * Math.cos(theta),
                    y: r * Math.sin(phi) * Math.sin(theta),
                    z: r * Math.cos(phi)
                };
            },
            HEART: (i) => {
                // Heart Surface Equation
                const r = 8; 
                let x, y, z;
                // Random point rejection to fill volume or surface
                let valid = false;
                while(!valid) {
                    const u = Math.random() * Math.PI * 2;
                    const v = Math.random() * Math.PI;
                    // Approximate parametric heart
                    x = 16 * Math.pow(Math.sin(v), 3) * Math.cos(u);
                    y = 13 * Math.cos(v) - 5 * Math.cos(2*v) - 2 * Math.cos(3*v) - Math.cos(4*v);
                    z = 8 * Math.pow(Math.sin(v), 3) * Math.sin(u); 
                    valid = true; 
                }
                return { x: x * r * 0.5, y: y * r * 0.5, z: z * r * 0.5 };
            },
            RINGS: (i) => {
                const r = 80 + Math.random() * 80;
                const theta = Math.random() * Math.PI * 2;
                // Flattened sphere (Saturn ring style)
                return {
                    x: r * Math.cos(theta),
                    y: (Math.random() - 0.5) * 10,
                    z: r * Math.sin(theta)
                };
            },
            GALAXY: (i) => {
                const arms = 5;
                const armOffset = Math.random() * 2 * Math.PI; 
                const spin = i / PARTICLE_COUNT * arms * Math.PI * 2;
                const r = Math.random() * 150;
                return {
                    x: r * Math.cos(spin + armOffset),
                    y: (Math.random() - 0.5) * (150 - r) * 0.5, // Thicker center
                    z: r * Math.sin(spin + armOffset)
                };
            }
        };

        const shapeKeys = Object.keys(Shapes);

        // --- INIT THREE.JS ---
        function initThree() {
            const container = document.getElementById('canvas-container');

            scene = new THREE.Scene();
            // Subtle fog for depth
            scene.fog = new THREE.FogExp2(0x050505, 0.002);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 2000);
            camera.position.z = CAM_Z;

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            container.appendChild(renderer.domElement);

            // Create Particles
            geometry = new THREE.BufferGeometry();
            positions = new Float32Array(PARTICLE_COUNT * 3);
            targetPositions = new Float32Array(PARTICLE_COUNT * 3);
            velocities = new Float32Array(PARTICLE_COUNT * 3);
            colors = new Float32Array(PARTICLE_COUNT * 3);

            const colorObj = new THREE.Color();

            for (let i = 0; i < PARTICLE_COUNT; i++) {
                // Initial Random Positions
                positions[i * 3] = (Math.random() - 0.5) * 800;
                positions[i * 3 + 1] = (Math.random() - 0.5) * 800;
                positions[i * 3 + 2] = (Math.random() - 0.5) * 800;

                velocities[i * 3] = 0;
                velocities[i * 3 + 1] = 0;
                velocities[i * 3 + 2] = 0;

                // Initial Target: Sphere
                const p = Shapes.SPHERE(i);
                targetPositions[i * 3] = p.x;
                targetPositions[i * 3 + 1] = p.y;
                targetPositions[i * 3 + 2] = p.z;

                // Base Colors (Cyan/Blue theme)
                colorObj.setHSL(0.5 + Math.random() * 0.2, 0.8, 0.6);
                colors[i * 3] = colorObj.r;
                colors[i * 3 + 1] = colorObj.g;
                colors[i * 3 + 2] = colorObj.b;
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

            // Custom texture for soft glow
            const sprite = new THREE.TextureLoader().load('https://threejs.org/examples/textures/sprites/spark1.png');

            material = new THREE.PointsMaterial({
                size: PARTICLE_SIZE,
                map: sprite,
                vertexColors: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false,
                transparent: true,
                opacity: 0.8
            });

            particles = new THREE.Points(geometry, material);
            scene.add(particles);

            // Lighting (for effect if we add meshes later, mostly affects particles if using specific shaders)
            const ambientLight = new THREE.AmbientLight(0x404040);
            scene.add(ambientLight);

            window.addEventListener('resize', onWindowResize);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // --- PHYSICS & ANIMATION LOOP ---
        function animate() {
            requestAnimationFrame(animate);
            
            time += 0.01;
            const delta = 1; // Simplified delta for physics steps

            // Rotate entire system slowly
            particles.rotation.y += 0.001;
            particles.rotation.z += 0.0005;

            const posAttribute = geometry.attributes.position;
            const colAttribute = geometry.attributes.color;
            const tempColor = new THREE.Color();

            // Main Particle Loop
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const idx = i * 3;
                
                let px = positions[idx];
                let py = positions[idx + 1];
                let pz = positions[idx + 2];

                let tx = targetPositions[idx];
                let ty = targetPositions[idx + 1];
                let tz = targetPositions[idx + 2];

                let vx = velocities[idx];
                let vy = velocities[idx + 1];
                let vz = velocities[idx + 2];

                // 1. Seek Target (Formation Force)
                // Spring force towards the defined shape position
                const forceX = (tx - px) * 0.02;
                const forceY = (ty - py) * 0.02;
                const forceZ = (tz - pz) * 0.02;

                vx += forceX;
                vy += forceY;
                vz += forceZ;

                // 2. Hand Interaction
                if (isHandPresent) {
                    // Calculate distance from particle to hand
                    const dx = px - handPosition.x;
                    const dy = py - handPosition.y;
                    const dz = pz - handPosition.z;
                    const distSq = dx*dx + dy*dy + dz*dz;
                    const dist = Math.sqrt(distSq);

                    if (dist < 200) {
                        if (isFist) {
                            // EXPLOSION (Repel)
                            const force = 8000 / (distSq + 1); // Inverse square law
                            vx += dx * force * 0.5;
                            vy += dy * force * 0.5;
                            vz += dz * force * 0.5;
                            
                            // Change color on explosion
                            tempColor.setHSL(0.05, 1.0, 0.5); // Red/Orange
                            colors[idx] = tempColor.r;
                            colors[idx+1] = tempColor.g;
                            colors[idx+2] = tempColor.b;
                            colAttribute.needsUpdate = true;

                        } else {
                            // ATTRACTION (Gravity Well)
                            const force = 300 / (dist + 10); 
                            vx -= (dx / dist) * force;
                            vy -= (dy / dist) * force;
                            vz -= (dz / dist) * force;
                            
                             // Change color on attract
                            tempColor.setHSL(0.6, 1.0, 0.7); // Bright Blue
                            colors[idx] = tempColor.r;
                            colors[idx+1] = tempColor.g;
                            colors[idx+2] = tempColor.b;
                            colAttribute.needsUpdate = true;
                        }
                    }
                }

                // 3. Noise / Drift (Simulates Brownian motion)
                vx += (Math.random() - 0.5) * 0.2;
                vy += (Math.random() - 0.5) * 0.2;
                vz += (Math.random() - 0.5) * 0.2;

                // 4. Physics Integration
                // Damping (Friction)
                vx *= 0.94;
                vy *= 0.94;
                vz *= 0.94;

                // Update Position
                positions[idx] += vx;
                positions[idx + 1] += vy;
                positions[idx + 2] += vz;

                // Update Velocity Storage
                velocities[idx] = vx;
                velocities[idx + 1] = vy;
                velocities[idx + 2] = vz;
            }

            posAttribute.needsUpdate = true;
            renderer.render(scene, camera);
        }

        function triggerShapeChange() {
            currentShapeIndex = (currentShapeIndex + 1) % shapeKeys.length;
            const shapeName = shapeKeys[currentShapeIndex];
            const generator = Shapes[shapeName];
            
            document.getElementById('status-text').innerText = `Formation: ${shapeName}`;
            document.getElementById('status-text').style.color = '#ff00ff';

            for(let i=0; i<PARTICLE_COUNT; i++) {
                const p = generator(i);
                targetPositions[i*3] = p.x;
                targetPositions[i*3+1] = p.y;
                targetPositions[i*3+2] = p.z;
                
                // Reset colors to base
                const colorObj = new THREE.Color();
                colorObj.setHSL(0.5 + Math.random() * 0.2, 0.8, 0.6);
                colors[i * 3] = colorObj.r;
                colors[i * 3 + 1] = colorObj.g;
                colors[i * 3 + 2] = colorObj.b;
            }
            geometry.attributes.color.needsUpdate = true;
            
            // Revert status text color after animation
            setTimeout(() => {
                document.getElementById('status-text').style.color = '#00ffff';
            }, 500);
        }


        // --- MEDIAPIPE SETUP ---
        const videoElement = document.getElementsByClassName('input_video')[0];

        function onResults(results) {
            document.getElementById('loading').style.display = 'none';

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                isHandPresent = true;
                const landmarks = results.multiHandLandmarks[0];

                // 1. Map Coordinates (Normalized 0-1 to Three.js World)
                // Note: Video X is mirrored. 
                const x = (1 - landmarks[9].x) * 2 - 1; // Center at 0
                const y = -(landmarks[9].y * 2 - 1); // Invert Y
                
                // Scale to world frustum approximately at z=0
                const vec = new THREE.Vector3(x, y, 0.5);
                vec.unproject(camera);
                
                const dir = vec.sub(camera.position).normalize();
                const distance = -camera.position.z / dir.z; // Project to Z=0 plane
                const pos = camera.position.clone().add(dir.multiplyScalar(distance));
                
                // Smooth movement
                handPosition.lerp(pos, 0.2);

                // 2. Gesture Detection
                
                // A. Fist Detection (Distance between wrist (0) and finger tips (8, 12, 16, 20))
                // Simple heuristic: if tips are close to wrist
                const wrist = landmarks[0];
                const tipIndex = landmarks[8];
                const tipMiddle = landmarks[12];
                
                const distIndex = Math.hypot(tipIndex.x - wrist.x, tipIndex.y - wrist.y);
                const distMiddle = Math.hypot(tipMiddle.x - wrist.x, tipMiddle.y - wrist.y);
                
                if (distIndex < 0.3 && distMiddle < 0.3) {
                    isFist = true;
                    document.getElementById('status-text').innerText = "Action: REPEL";
                } else {
                    isFist = false;
                    document.getElementById('status-text').innerText = "Action: ATTRACT";
                }

                // B. Pinch Detection (Thumb tip 4 vs Index tip 8)
                const tipThumb = landmarks[4];
                const pinchDist = Math.hypot(tipIndex.x - tipThumb.x, tipIndex.y - tipThumb.y);
                
                if (pinchDist < 0.05) {
                    if (!isPinching && !pinchCooldown) {
                        triggerShapeChange();
                        pinchCooldown = true;
                        setTimeout(() => { pinchCooldown = false }, 1000);
                    }
                    isPinching = true;
                } else {
                    isPinching = false;
                }

            } else {
                isHandPresent = false;
                document.getElementById('status-text').innerText = "Searching for hand...";
            }
        }

        const hands = new Hands({locateFile: (file) => {
            return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
        }});

        hands.setOptions({
            maxNumHands: 2,
            modelComplexity: 1,
            minDetectionConfidence: 0.7,
            minTrackingConfidence: 0.7
        });

        hands.onResults(onResults);

        const cameraUtils = new Camera(videoElement, {
            onFrame: async () => {
                await hands.send({image: videoElement});
            },
            width: 1280,
            height: 720
        });
        
        // Start everything
        initThree();
        cameraUtils.start();
        animate();

    </script>
</body>
</html>